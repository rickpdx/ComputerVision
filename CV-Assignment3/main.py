# Ricardo Cruz
# CS4/510 Computer Vision
# Programming 4

import numpy as np
import cv2 as cv
import tensorflow as tf
from tensorflow.keras.applications.vgg16 import VGG16
from tensorflow.keras.applications.vgg16 import preprocess_input
from tensorflow.keras.applications.imagenet_utils import decode_predictions
from tensorflow.keras.preprocessing import image
from tensorflow.keras import backend as K
tf.compat.v1.disable_eager_execution()


# Method for obtaining the top ranked index
# Params: rank number and prediction numpy array 
# Return: index and prediction
def find_rank_index(rank, y_pred):
    index = np.argmax(y_pred)
    top = decode_predictions(y_pred, top=1)
    if rank >= 2:
        mod_prediction = y_pred
        mod_prediction[:, index] = 0.0
        index = np.argmax(mod_prediction)
        top = decode_predictions(mod_prediction, top=1)

    return index, top

# Creates gradient
# Params: keras model, index, preprocessed input
# Returns: outputs and gradient values
def generate_gradient(model, ix, X):
    last_layer = model.get_layer('block5_conv3')
    gradient = K.gradients(model.output[:, ix], last_layer.output)[0]
    grad_f = K.function(
        [model.input], [last_layer.output, gradient])
    out, g_val = grad_f([X])
    out, g_val = out[0, :], g_val[0, :, :, :]

    return out, g_val

# Grad-cam method
# Used to generate a visual explanation for the predictions made by the model
# Params: original img, keras model, prediction numpy array, preprocessed input, and test image id number
# Writes sliency heatmap and saliency heatmap supeimposed on top of original input image
def grad_cam(img, model, prediction, x, num):

    # Get Top ranked, second ranked, and third ranked class for the test image generated by VGG-16
    for i in range(1, 4):
        # Get desired rank index
        index, top = find_rank_index(i, prediction)

        # Generate gradient values and outputs
        output, g_val = generate_gradient(
            model, index, x)
        weights = np.mean(g_val, axis=(0, 1))
        g_cam = np.dot(output, weights)
        g_cam = g_cam * (g_cam > 0)

        # Bi-linear interpolation
        g_cam = cv.resize(g_cam, (224, 224), cv.INTER_LINEAR)
        g_cam = np.maximum(g_cam, 0)
        g_cam_max = g_cam.max()
        if g_cam_max != 0:
            g_cam = g_cam / g_cam_max

        # Prepare saliency heatmap
        heatmap = cv.applyColorMap(np.uint8(255 * g_cam), cv.COLORMAP_JET)

        # Get prediction string
        for j in top:
            for k in j:
                pred_class = k[1]

        # Visualization of the saliency heatmap
        output_str1 = 'saliencyHeatmap' + str(num+1) + '_' + \
            'RankedClass' + str(i) + '_' + pred_class + '.jpg'
        sal_hm = np.uint8(heatmap)
        font = cv.FONT_HERSHEY_SIMPLEX
        color = (255, 255, 255)
        cv.putText(sal_hm, pred_class, (45, 25),
                   font, 0.7, color, 2)
        cv.imwrite(output_str1, sal_hm)

        # Visualization of the saliency heatmap superimposed on top of input image
        heatmap = (np.float32(heatmap) + img) / 2
        output_str2 = 'gradcam' + str(num+1) + '_' + \
            'RankedClass' + str(i) + '_' + pred_class + '.jpg'
        combined = np.uint8(heatmap)
        cv.imwrite(output_str2, combined)

def main():
    # Instantiate pretrained model
    model = VGG16(weights='imagenet', include_top=True)

    # Repeat for each test image
    for i in range(5):
        # Read in test image and preprocess
        src = 'data/gc' + str(i+1) + '.jpg'
        img = image.load_img(src, target_size=(224, 224))
        img = cv.cvtColor(np.uint8(img), cv.COLOR_BGR2RGB)
        x = image.img_to_array(img)
        x = np.expand_dims(x, axis=0)
        x = preprocess_input(x)

        # Write input image for report
        outputstr = 'inputImage_' + str(i+1) + '.jpg'
        cv.imwrite(outputstr, np.uint8(img))

        # Generate prediction numpy array and print results for top 3 classes
        prediction = model.predict(x)
        print(decode_predictions(prediction, top=3))

        # Grad-cam 
        grad_cam(img, model, prediction, x, i)

if __name__ == "__main__":
    main()
